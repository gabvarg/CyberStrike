<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBER-STRIKE: FIXED EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');

        :root {
            --neon-green: #39ff14;
            --neon-red: #ff003c;
            --neon-blue: #00f3ff;
            --dark: #020205;
        }

        * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }

        body, html {
            margin: 0; padding: 0;
            width: 100%; min-height: 100vh;
            background: var(--dark);
            color: var(--neon-green);
            font-family: 'Share Tech Mono', monospace;
            display: flex; align-items: center; justify-content: center;
            overflow-x: hidden;
        }

        #matrix-bg { position: fixed; top: 0; left: 0; z-index: -1; opacity: 0.15; }

        .main-interface {
            background: rgba(5, 10, 5, 0.95);
            border: 2px solid var(--neon-green);
            padding: 15px;
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.2);
            width: 95%; max-width: 600px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .header-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px; margin-bottom: 15px;
            border-bottom: 1px solid var(--neon-green);
            padding-bottom: 10px;
        }

        .stat-box { text-align: center; border: 1px solid rgba(57, 255, 20, 0.2); padding: 5px; }
        .stat-label { font-size: 9px; color: var(--neon-blue); text-transform: uppercase; display: block; }
        .stat-value { font-size: 16px; font-family: 'Orbitron'; color: #fff; }

        #board-container {
            width: 100%;
            overflow: auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 1px solid var(--neon-green);
            margin-bottom: 15px;
            display: flex; justify-content: center;
        }

        #board { display: grid; gap: 2px; margin: 0 auto; }

        .cell {
            width: clamp(30px, 9vw, 40px);
            height: clamp(30px, 9vw, 40px);
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid rgba(57, 255, 20, 0.2);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-weight: bold; font-size: 16px;
            user-select: none; transition: 0.1s;
        }

        .cell:hover:not(.revealed) { background: var(--neon-green); color: var(--dark); }
        .cell.revealed { background: rgba(255, 255, 255, 0.05); border-color: transparent; color: #fff; }
        .cell.mine { background: var(--neon-red); color: white; }
        .cell.flagged { color: var(--neon-red); }

        .controls { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 10px;
        }

        select, button {
            background: transparent; color: var(--neon-green);
            border: 1px solid var(--neon-green); padding: 12px;
            font-family: 'Share Tech Mono'; cursor: pointer;
            text-transform: uppercase; font-size: 12px;
        }

        button:active { transform: scale(0.95); }
        #btn-mode { color: var(--neon-blue); border-color: var(--neon-blue); }
        #btn-mode.active-flag { background: var(--neon-red); color: white; border-color: var(--neon-red); }

        #audio-init {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--dark); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        .n1 { color: var(--neon-blue); } .n2 { color: var(--neon-green); } 
        .n3 { color: var(--neon-red); } .n4 { color: #fcee0a; }

        @media (max-width: 480px) {
            .header-panel { grid-template-columns: 1fr 1fr; }
            .stat-box:last-child { grid-column: span 2; }
            .controls { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div id="audio-init">
        <h1 style="font-family: 'Orbitron'; color: var(--neon-green);">CYBER-STRIKE</h1>
        <button onclick="startSystem()">[ ENTRAR AL SISTEMA ]</button>
    </div>

    <canvas id="matrix-bg"></canvas>

    <div class="main-interface" id="ui-main" style="display:none;">
        <div class="header-panel">
            <div class="stat-box"><span class="stat-label">Cores</span><span id="mine-count" class="stat-value">000</span></div>
            <div class="stat-box"><span class="stat-label">Score</span><span id="score-display" class="stat-value">0000</span></div>
            <div class="stat-box"><span class="stat-label">Status</span><span id="status-text" class="stat-value">ONLINE</span></div>
        </div>

        <div id="board-container">
            <div id="board"></div>
        </div>

        <div class="controls">
            <select id="mode-select" onchange="initGame()">
                <option value="easy">SCRIPTER (10x10)</option>
                <option value="medium">PHREAKER (16x16)</option>
                <option value="hard">ARCHITECT (30x16)</option>
            </select>
            <button onclick="initGame()">REBOOT</button>
            <button id="btn-mode" onclick="toggleTouchMode()">MODO: EXCAVAR</button>
            <button onclick="alert('Récords online próximamente...')">LEADERBOARD</button>
        </div>
    </div>

    <script>
        let audioCtx;
        function initAudio() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function playSfx(f, t, d, v) {
            if(!audioCtx) return;
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
            g.gain.setValueAtTime(v, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + d);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(); o.stop(audioCtx.currentTime + d);
        }

        const canvas = document.getElementById('matrix-bg');
        const ctx = canvas.getContext('2d');
        let w, h, drops;
        function resize() {
            w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight;
            drops = Array(Math.floor(w/20)).fill(1);
        }
        function drawMatrix() {
            ctx.fillStyle = 'rgba(2,2,5,0.1)'; ctx.fillRect(0,0,w,h);
            ctx.fillStyle = '#0F0'; ctx.font = '15px monospace';
            drops.forEach((y, i) => {
                const txt = String.fromCharCode(Math.random()*128);
                ctx.fillText(txt, i*20, y*20);
                if(y*20 > h && Math.random() > 0.98) drops[i] = 0;
                drops[i]++;
            });
        }
        window.addEventListener('resize', resize); resize();
        setInterval(drawMatrix, 50);

        const MODES = { easy: {r:10, c:10, m:10}, medium: {r:16, c:16, m:40}, hard: {r:16, c:30, m:99} };
        let grid = [], active = false, score = 0, flags = 0, maxMines = 0, touchMode = 'dig';

        function startSystem() {
            initAudio();
            document.getElementById('audio-init').style.display = 'none';
            document.getElementById('ui-main').style.display = 'block';
            initGame();
        }

        function toggleTouchMode() {
            touchMode = (touchMode === 'dig') ? 'flag' : 'dig';
            const btn = document.getElementById('btn-mode');
            btn.textContent = touchMode === 'dig' ? 'MODO: EXCAVAR' : 'MODO: BANDERA';
            btn.className = touchMode === 'flag' ? 'active-flag' : '';
            playSfx(300, 'square', 0.1, 0.05);
        }

        function initGame() {
            const config = MODES[document.getElementById('mode-select').value];
            const board = document.getElementById('board');
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${config.c}, 1fr)`;
            board.style.width = config.c > 15 ? 'max-content' : '100%';
            
            grid = []; active = true; score = 0; flags = 0; maxMines = config.m;
            document.getElementById('status-text').textContent = "ONLINE";
            updateUI();

            for(let r=0; r<config.r; r++) {
                grid[r] = [];
                for(let c=0; c<config.c; c++) {
                    grid[r][c] = {r, c, mine:false, rev:false, flg:false, n:0};
                    const el = document.createElement('div');
                    el.className = 'cell'; el.id = `cell-${r}-${c}`;
                    el.addEventListener('click', () => handleInput(r, c));
                    el.addEventListener('contextmenu', (e) => { e.preventDefault(); flag(r, c); });
                    board.appendChild(el);
                }
            }

            let m = 0;
            while(m < config.m) {
                let rr = Math.floor(Math.random()*config.r), rc = Math.floor(Math.random()*config.c);
                if(!grid[rr][rc].mine) { grid[rr][rc].mine = true; m++; }
            }

            for(let r=0; r<config.r; r++) {
                for(let c=0; c<config.c; c++) {
                    if(grid[r][c].mine) continue;
                    let n = 0;
                    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++)
                        if(grid[r+i] && grid[r+i][c+j] && grid[r+i][c+j].mine) n++;
                    grid[r][c].n = n;
                }
            }
        }

        function handleInput(r, c) {
            if(!active) return;
            if(touchMode === 'flag') flag(r, c); else reveal(r, c);
        }

        function reveal(r, c) {
            if(!grid[r] || !grid[r][c] || grid[r][c].rev || grid[r][c].flg) return;
            const cell = grid[r][c];
            cell.rev = true;
            const el = document.getElementById(`cell-${r}-${c}`);
            el.classList.add('revealed');

            if(cell.mine) {
                playSfx(100, 'sawtooth', 0.5, 0.2);
                gameOver(false);
            } else {
                playSfx(500 + (cell.n * 50), 'sine', 0.05, 0.05);
                score += 10; updateUI();
                if(cell.n > 0) {
                    el.textContent = cell.n;
                    el.classList.add('n' + cell.n);
                } else {
                    for(let i=-1; i<=1; i++) {
                        for(let j=-1; j<=1; j++) {
                            if(i !== 0 || j !== 0) reveal(r+i, c+j);
                        }
                    }
                }
                checkWin();
            }
        }

        function flag(r, c) {
            const cell = grid[r][c];
            if(cell.rev) return;
            if(!cell.flg && flags >= maxMines) return;
            cell.flg = !cell.flg;
            flags += cell.flg ? 1 : -1;
            playSfx(200, 'square', 0.05, 0.05);
            document.getElementById(`cell-${r}-${c}`).textContent = cell.flg ? '⚠' : '';
            document.getElementById(`cell-${r}-${c}`).classList.toggle('flagged');
            updateUI();
        }

        function updateUI() {
            document.getElementById('mine-count').textContent = (maxMines - flags).toString().padStart(3,'0');
            document.getElementById('score-display').textContent = score.toString().padStart(4,'0');
        }

        function gameOver(win) {
            active = false;
            document.getElementById('status-text').textContent = win ? "CLEAN" : "ERROR";
            grid.flat().forEach(c => {
                if(c.mine) {
                    const el = document.getElementById(`cell-${c.r}-${c.c}`);
                    el.classList.add('mine'); el.textContent = '☢';
                }
            });
        }

        function checkWin() {
            const config = MODES[document.getElementById('mode-select').value];
            const revCount = grid.flat().filter(c => c.rev).length;
            if(revCount === (config.r * config.c) - config.m) gameOver(true);
        }
    </script>
</body>
</html>
