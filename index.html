<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CyberDash - Mini Juego</title>
  <style>
    :root {
      --bg: #090b12;
      --panel: #121725;
      --accent: #00e5ff;
      --danger: #ff4d6d;
      --text: #f5f7ff;
      --muted: #9ca3af;
      --good: #22c55e;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, sans-serif;
    }

    body {
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at top, #16203a 0%, var(--bg) 45%);
      color: var(--text);
      padding: 16px;
    }

    .wrapper {
      width: min(92vw, 760px);
      display: grid;
      gap: 12px;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 14px;
      border: 1px solid #27314b;
      border-radius: 12px;
      background: linear-gradient(180deg, #111827, #0b1020);
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
    }

    .hud strong {
      color: var(--accent);
    }

    .help {
      font-size: 0.9rem;
      color: var(--muted);
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid #263146;
      background: linear-gradient(180deg, #0f172a, #020617);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(2, 6, 23, 0.7);
      backdrop-filter: blur(2px);
      transition: opacity 0.2s ease;
    }

    .panel {
      width: min(90vw, 400px);
      background: var(--panel);
      border: 1px solid #25324a;
      border-radius: 14px;
      padding: 20px;
      text-align: center;
    }

    .panel h1 {
      font-size: 1.5rem;
      margin-bottom: 8px;
    }

    .panel p {
      color: var(--muted);
      margin-bottom: 12px;
    }

    button {
      background: var(--accent);
      color: #001018;
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease;
    }

    button:hover {
      transform: translateY(-1px);
    }

    .hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="hud">
      <div>Puntaje: <strong id="score">0</strong></div>
      <div>Mejor: <strong id="best">0</strong></div>
      <div class="help">Mover: ← → o A D | Reiniciar: R</div>
    </div>
    <canvas id="game" width="760" height="420" aria-label="Juego CyberDash"></canvas>
  </div>

  <div id="overlay" class="overlay">
    <div class="panel">
      <h1>CyberDash</h1>
      <p>Evita los drones rojos y sobrevive lo máximo posible.</p>
      <button id="startBtn">Jugar</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');

    const state = {
      running: false,
      score: 0,
      best: Number(localStorage.getItem('cyberdash_best') || 0),
      speed: 2.3,
      spawnRate: 950,
      lastSpawn: 0,
      stars: [],
      keys: new Set()
    };

    const player = {
      x: canvas.width / 2 - 17,
      y: canvas.height - 58,
      w: 34,
      h: 34,
      speed: 5.8
    };

    let enemies = [];
    let lastTime = 0;

    function resetGame() {
      state.score = 0;
      state.speed = 2.3;
      state.spawnRate = 950;
      state.lastSpawn = 0;
      player.x = canvas.width / 2 - player.w / 2;
      enemies = [];
      state.stars = Array.from({ length: 60 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        s: Math.random() * 1.8 + 0.2,
        v: Math.random() * 0.6 + 0.2
      }));
      scoreEl.textContent = '0';
      bestEl.textContent = String(state.best);
    }

    function spawnEnemy() {
      const size = 20 + Math.random() * 22;
      enemies.push({
        x: Math.random() * (canvas.width - size),
        y: -size,
        w: size,
        h: size,
        speed: state.speed + Math.random() * 1.5
      });
    }

    function drawRoundedRect(x, y, w, h, r, fill) {
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }

    function collide(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function update(delta, timestamp) {
      if (state.keys.has('ArrowLeft') || state.keys.has('a')) {
        player.x -= player.speed;
      }
      if (state.keys.has('ArrowRight') || state.keys.has('d')) {
        player.x += player.speed;
      }
      player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));

      state.stars.forEach((star) => {
        star.y += star.v * (1 + state.speed / 5);
        if (star.y > canvas.height) {
          star.y = -2;
          star.x = Math.random() * canvas.width;
        }
      });

      if (timestamp - state.lastSpawn > state.spawnRate) {
        state.lastSpawn = timestamp;
        spawnEnemy();
      }

      enemies.forEach((enemy) => {
        enemy.y += enemy.speed * delta;
      });

      enemies = enemies.filter((enemy) => enemy.y < canvas.height + enemy.h);

      if (enemies.some((enemy) => collide(player, enemy))) {
        gameOver();
        return;
      }

      state.score += delta * 8;
      state.speed += delta * 0.02;
      state.spawnRate = Math.max(360, state.spawnRate - delta * 0.35);
      scoreEl.textContent = String(Math.floor(state.score));
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      state.stars.forEach((star) => {
        ctx.fillStyle = '#9fb8ff';
        ctx.globalAlpha = 0.35;
        ctx.fillRect(star.x, star.y, star.s, star.s);
      });
      ctx.globalAlpha = 1;

      drawRoundedRect(player.x, player.y, player.w, player.h, 8, '#00e5ff');
      ctx.fillStyle = '#001c28';
      ctx.fillRect(player.x + 8, player.y + 8, 18, 18);

      enemies.forEach((enemy) => {
        drawRoundedRect(enemy.x, enemy.y, enemy.w, enemy.h, 6, '#ff4d6d');
        ctx.fillStyle = '#4a0010';
        ctx.fillRect(enemy.x + enemy.w * 0.24, enemy.y + enemy.h * 0.24, enemy.w * 0.52, enemy.h * 0.52);
      });
    }

    function loop(timestamp = 0) {
      if (!state.running) return;
      const delta = Math.min((timestamp - lastTime) / 16.67, 2.5);
      lastTime = timestamp;

      update(delta, timestamp);
      draw();
      requestAnimationFrame(loop);
    }

    function startGame() {
      resetGame();
      state.running = true;
      overlay.classList.add('hidden');
      startBtn.textContent = 'Reintentar';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      state.running = false;
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem('cyberdash_best', String(state.best));
      bestEl.textContent = String(state.best);
      overlay.classList.remove('hidden');
    }

    document.addEventListener('keydown', (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      state.keys.add(key);

      if (key.toLowerCase() === 'r' && !state.running) {
        startGame();
      }
    });

    document.addEventListener('keyup', (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      state.keys.delete(key);
    });

    startBtn.addEventListener('click', startGame);
    resetGame();
    draw();
  </script>
</body>
</html>
